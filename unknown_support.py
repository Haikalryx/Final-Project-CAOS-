#! /usr/bin/env python
#
# Support module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6
#    Jan 22, 2018 03:53:30 PM
############ shereef ####


import matplotlib, numpy, sys
from matplotlib.figure import Figure
matplotlib.use('TkAgg')

from numpy import arange, sin, pi
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
# implement the default mpl key bindings
from matplotlib.backend_bases import key_press_handler


###########


import sys

try:
   from Tkinter import *
except ImportError:
   from tkinter import *


try:
   import ttk
   py3 = 0
except ImportError:
   import tkinter.ttk as ttk
   py3 = 1


def init(top, gui, *args, **kwargs):
   global w, top_level, root
   w = gui
   top_level = top
   root = top
   defaultRow()
   defaultRowH()


def destroy_window():
   # Function which closes the window.
   global top_level
   top_level.destroy()
   top_level = None


import tkinter as tk
from tkinter import ttk

######## shereef ############


burstTimeArr = [1,2,3]
arrivalTimeArr = []

entries1 = []
entries2 = []
entries3 = []
e2 = 0
e3 = 0
et = 0



def deleteRow():
    if(w.rowCount == 1):
        w.Label6.configure(text="Cannot delete first row")
    else:

        w.Label6.configure(text="Row deleted")
        entries1[len(entries1)-1].destroy()
        del entries1[len(entries1)-1]
        entries2[len(entries2)-1].destroy()
        del entries2[len(entries2)-1]
        entries3[len(entries3)-1].destroy()
        del entries3[len(entries3)-1]
        w.rowCount -= 1


def defaultRow():
    w.rowCount += 1

    stringRowCount = "" + str(w.rowCount)
    en1 = Entry(w.Frame4, width=39)
    en1.insert(0, "P" + stringRowCount)
    en1.grid(row=w.rowCount + 1, column=0)
    entries1.append(en1)
    en1.configure(state='disabled')

    en2 = Entry(w.Frame4, width=39)
    en2.grid(row=w.rowCount + 1, column=1)
    entries2.append(en2)

    en3 = Entry(w.Frame4, width=38)
    en3.grid(row=w.rowCount + 1, column=2)
    entries3.append(en3)

    # w.Canvas1.configure(scrollregion=w.Canvas1.bbox("all"))


def createRow():
    w.rowCount += 1
    if(w.rowCount != 1):
        # print(w.rowCount, "text: '", entries1[w.rowCount-2].get())
        if(entries2[w.rowCount - 2].get() == ""
                or entries3[w.rowCount - 2].get() == ""
                or not entries3[w.rowCount - 2].get().isdigit()
                or not entries2[w.rowCount - 2].get().isdigit()):
            w.Label6.configure(text="Entry cant be null or non-numeric")
            print("Error")
            w.rowCount -= 1
        else:

            w.Label6.configure(text="Created new row")
            stringRowCount = "" + str(w.rowCount)
            en1 = Entry(w.Frame4, width=39)
            en1.insert(0,"P" + stringRowCount)
            en1.grid(row= w.rowCount+1, column=0)
            entries1.append(en1)
            en1.configure(state='disabled')

            en2 = Entry(w.Frame4, width=39)
            en2.grid(row= w.rowCount+1, column=1)
            entries2.append(en2)

            en3 = Entry(w.Frame4, width=38)
            en3.grid(row= w.rowCount+1, column=2)
            entries3.append(en3)
            # print(entries3[w.rowCount - 2].get().isdigit())

            w.Canvas1.configure(scrollregion=w.Canvas1.bbox("all"))


def printConsole1():


    entries1String = []
    entries2String = []
    entries3String = []
    entries2Int = []
    entries3Int = []
    entriesArrivalInt = []
    addEntriesInt = []
    turnAroundTime = []
    waitingTime = []

    w.conditionIdleLoop = True

    # print(w.rowCount, "text: '", entries1[w.rowCount-2].get())
    if(entries2[w.rowCount - 2].get() == "" or entries3[w.rowCount - 2].get() == "" or not entries3[w.rowCount - 2].get().isdigit() or not entries2[w.rowCount - 2].get().isdigit()):
        w.Label6.configure(text="Entry cant be null or non-numeric")
        print("Error")
    else:

        w.Label6.configure(text="Done! Gantt Chart populated")
        print("\n####### Part-1 ##################")

        for entry in entries1:
            entries1String.append(str(entry.get()))
            print("E1: ",entry.get(), end=", ")
        print("")

        for entry in entries2:
            entries2String.append(str(entry.get()))
            entries2Int.append(int(entry.get()))
            print("E2: ", entry.get(), end=", ")
        print("")

        for entry in entries3:
            entries3String.append(str(entry.get()))
            entries3Int.append(int(entry.get()))
            print("E3: ", entry.get(), end=", ")
        print("")

        for entry1, entry2 in zip(entries2Int, entries3Int):
            addEntriesInt.append(entry1 + entry2)
            print("ET: ", str(entry1 + entry2), end=", ")
        print("\n")

        entriesArrivalInt = list(entries2Int)

        for e in entriesArrivalInt:
            print("E2A: ", e, end=", ")



        print("\n####### Part-2 ##################")

        #change the arrival time appropriate to the burst time
        for entry in range(len(addEntriesInt) - 1):
            if(addEntriesInt[w.i] > entries2Int[w.i + 1]):
                entries2Int[w.i + 1] = addEntriesInt[w.i]
                addEntriesInt[w.i + 1] = entries2Int[w.i + 1] + entries3Int[w.i + 1]

            w.i +=1

        ###############

        for e in entries2Int:
            print("C-E2: ", e, end=", ")
        print("")
        for e in addEntriesInt:
            print("C-ET: ", e, end=", ")

        print("")

        ##############

        w.i = 0


        for entry in addEntriesInt:
            turnAroundTime.insert(w.i, addEntriesInt[w.i] - entriesArrivalInt[w.i])
            waitingTime.insert(w.i, turnAroundTime[w.i] - entries3Int[w.i])
            w.i += 1

        w.i = 0

        turnAroundTimeAVG = 0.00
        waitingTimeAVG = 0.00


        print("\n####### Part-3 ##################")

        for entry in addEntriesInt:
            print("T[", addEntriesInt[w.i], "-", entriesArrivalInt[w.i], "=", turnAroundTime[w.i], "]", end='')
            print("W[", turnAroundTime[w.i], "-", entries3Int[w.i], "=",waitingTime[w.i], "]", end='')

            turnAroundTimeAVG += turnAroundTime[w.i]
            waitingTimeAVG += waitingTime[w.i]

            w.i += 1

        # print("\n")
        # print("\n")


        print("\n####### Part-4 ##################")

        turnAroundTimeAVG = turnAroundTimeAVG/w.rowCount
        waitingTimeAVG = waitingTimeAVG/w.rowCount

        w.aveTurnTime.configure(text=turnAroundTimeAVG)
        w.aveWaitTime.configure(text=waitingTimeAVG)

        w.i = 0

        # If the first value's arrival time non-zero, then need an idle before the process
        if (entries2Int[0] != 0):
            e2 = 0
            e3 = (entries2Int[0])
            et = e3

            entries1String.insert(w.i, "Idle")
            entries2Int.insert(w.i, e2)
            entries3Int.insert(w.i, e3)
            addEntriesInt.insert(w.i, et)

        w.i =0
        for e in addEntriesInt:
            print("E1: ", entries1String[w.i], " E2: ", entries2Int[w.i], " E3: ", entries3Int[w.i], " ET: ", addEntriesInt[w.i])
            w.i += 1

        w.i = 0

        while w.conditionIdleLoop:
            w.conditionIdleLoop = False
            if(w.i < len(addEntriesInt)-1):
                w.conditionIdleLoop = True

                if (addEntriesInt[w.i] != entries2Int[w.i + 1]):
                    e2 = addEntriesInt[w.i]
                    e3 = (entries2Int[w.i + 1] - addEntriesInt[w.i])
                    et = (addEntriesInt[w.i] + (entries2Int[w.i + 1] - addEntriesInt[w.i]))

                    entries1String.insert(w.i + 1, "Idle")
                    entries2Int.insert(w.i + 1, e2)
                    entries3Int.insert(w.i + 1, e3)
                    addEntriesInt.insert(w.i + 1, et)

                w.i += 1

        w.i = 0

        for entry in addEntriesInt:
            # print("[", entries1String[w.i], ",", entries2Int[w.i], "-", addEntriesInt[w.i], "]", end='')
            print("[", entries1String[w.i], ",", entries2Int[w.i], "-", entries3Int[w.i], addEntriesInt[w.i], "]", end='')
            w.i += 1


        print("\n")

        ##################

        entries3Int.insert(0,0) #bursttime
        addEntriesInt.insert(0,0) #timeline
        entries1String.insert(0,"") #processname

        # w.f = Figure(figsize=(5, 4), dpi=100)
        if(w.loopCount==0):
            w.ax = w.f.add_subplot(2, 1, 1)
        else:
            w.ax = w.ax.clear()
            w.ax = w.f.add_subplot(2, 1, 1)

        process = ("P1", "P2", "P3", "P4", "P5")

        ind = numpy.arange(1)  # the x locations for the groups
        width = .95

        data = [5,3,1,2,3]
        data1 = [5,8,9,11,14]
        # data1 = [1, 3, 4, 5, 6, 1, 2]

        patch_handles = []
        patch_handles1 = []

        left = 1

        qr = 0
        qriter = 0

        for i, d in enumerate(entries3Int):
            if (d == 0):
                qr = qriter
            patch_handles.append(w.ax.barh(ind, d, align='center', left=left, yerr=0.4, color='#8FC97F'))
            left += d

            z = 0

        for j in range(len(patch_handles)):
            for i, patch in enumerate(patch_handles[j].get_children()):
                bl = patch.get_xy()
                x = 0.5 * patch.get_width() + bl[0]
                y = 0.5 * patch.get_height() + bl[1]
                # print(patch.get_width())
                if (patch.get_width() == 0):
                    w.ax.text(x, y, entries1String[z], ha='center')
                else:
                    w.ax.text(x, y, entries1String[z], ha='center')
                z+=1

        w.ax.set_yticks(ind)
        w.ax.set_yticklabels(" ")
        w.ax.set_xticks(numpy.cumsum(entries3Int) + 1)
        w.ax.set_xticklabels(addEntriesInt)
        # self.ax.set_xlim(1, 20)
        w.ax.set_xlabel('Gantt Chart')
        # self.ax.scatter(1,2,100)

        # w.canvas = FigureCanvasTkAgg(w.f, master=w.Frame5)
        w.canvas.show()
        w.canvas.get_tk_widget().pack(side=BOTTOM, fill=BOTH, expand=1)

        # toolbar = NavigationToolbar2TkAgg(w.canvas, root)
        w.toolbar.update()
        # w.canvas._canvas.pack(side=TOP, fill=BOTH, expand=True)


        ###############

        # Clear the list used for avoiding index limit errors
        w.i = 0
        w.j = 0

        # entries1String[:] = []
        # entries2String[:] = []
        # entries3String[:] = []
        # entries2Int[:] = []
        # entries3Int[:] = []
        # entriesArrivalInt[:] = []
        # addEntriesInt[:] = []
        # turnAroundTime[:] = []
        # waitingTime[:] = []

        entries1String.clear()
        entries2String.clear()
        entries3String.clear()
        entries2Int.clear()
        entries3Int.clear()
        entriesArrivalInt.clear()
        addEntriesInt.clear()
        turnAroundTime.clear()
        waitingTime.clear()

        w.loopCount += 1


##################################




##################### Nazrul ###################

My_Blocks = []
My_Alignment = []
My_Process = []
My_Alignment2 = []
Selection = []
BestDiagram = [[], [], []]
My_Process.append([])
My_Process.append([])
BlockUsed = []
ProcessUsed = []
FreeSpace = []
oneClick = 0
count = 0
align = 0
infrag = 0
exfrag = 0
textAlign = 0
processCount = 0

def printval():
   global count, align, textAlign
   string = w.EntryN1.get()
   stringVal = int(string)
   if stringVal >= 10:
       My_Blocks.insert(count, int(string))

       size = int(My_Blocks[count])
       align += size
       textAlign += size
       My_Alignment.insert(count, align)

       if count < 1:
           w.CanvasN1.create_rectangle(10, 5, 160, align)
           w.CanvasN1.create_text(85, textAlign / 2, text=string + "Mb")
       else:
           w.CanvasN1.create_rectangle(10, My_Alignment[count - 1], 160, align)
           w.CanvasN1.create_text(85, My_Alignment[count - 1] + size / 2, text=string + "Mb")

       count += 1
       w.CanvasN1.config(scrollregion=(0, 0, 1000, My_Alignment[count - 1] + 25))
       w.EntryN1.delete(0, END)


def clearAll():
   global count, align, textAlign
   count = 0
   align = 0
   textAlign = 0
   My_Blocks.clear()
   w.CanvasN1.delete(ALL)


def addProcess():
   global processCount, My_Process
   process = int(w.EntryN2.get())
   processsize = int(w.EntryN3.get())
   if processsize >= 10:
       if len(My_Process[0]) < 5:
           if process not in My_Process[0]:
               My_Process[0].insert(processCount, process)
               My_Process[1].insert(processCount, processsize)
               w.ListboxN1.insert(processCount, process)
               w.ListboxN2.insert(processCount, processsize)
               processCount += 1
               ProcessUsed.insert(processCount, False)

   w.EntryN2.delete(0, END)
   w.EntryN3.delete(0, END)


def clearProcess():
   w.ListboxN1.delete(0, END)
   w.ListboxN2.delete(0, END)

   My_Process[0].clear()
   My_Process[1].clear()


def BestFit():
   global infrag, exfrag, processFit, block, oneClick, checkAllignment
   if oneClick <= 0:
                   block = list(map(int, My_Blocks))
                   processFit = list(map(int, My_Process[1]))
                   select = list(map(int, Selection))
                   check = My_Blocks[0]
                   checkAllignment = []

                   for y in range(len(My_Blocks)):
                           BlockUsed.insert(y, False)
                           FreeSpace.insert(y, 0)

                           if y < 1:
                               w.CanvasN2.create_rectangle(10, 5, 160, My_Blocks[0])
                               checkAllignment.insert(y, My_Blocks[0])
                           else:
                               w.CanvasN2.create_rectangle(10, check, 160, check + My_Blocks[y])
                               check += My_Blocks[y]
                               checkAllignment.insert(y, check)

                   w.CanvasN2.config(scrollregion=(0, 0, 1000, checkAllignment[y] + 25))
                   processFit.sort(reverse=True)

                   for t in range(len(processFit)):
                       varify = -1


                       for p in range(len(block)):

                               if block[p] >= processFit[t]:
                                   if varify == -1:
                                       varify = p
                                   elif block[varify] > block[p]:
                                       varify = p
                               for s in range(len(FreeSpace)):
                                   if processFit[t]<= FreeSpace[s]:
                                       print(processFit)
                                       print(FreeSpace)
                                       varify == -1




                       if varify != -1:
                                       BlockUsed[varify] = True
                                       ProcessUsed[t] = True

                                       unused = block[varify] - processFit[t]
                                       FreeSpace[varify] = unused
                                       txt = str(processFit[t])
                                       txtF = str(unused)
                                       infrag += unused

                                       if varify == 0:
                                           w.CanvasN2.create_rectangle(10, 5 + unused, 160, checkAllignment[0], fill="#046363")
                                           w.CanvasN2.create_text(85, checkAllignment[0] - 20, text=txt+"Mb", fill = "#0000ff")
                                           if unused > 0:
                                                         w.CanvasN2.create_text(85, unused, text=txtF + "Mb")

                                       else:

                                           w.CanvasN2.create_rectangle(10, checkAllignment[varify - 1] + unused, 160, checkAllignment[varify],
                                                                      fill="#046363")
                                           w.CanvasN2.create_text(85, checkAllignment[varify] - 20, text=txt+"Mb", fill = "#0000ff")
                                           if unused > 0:
                                                         w.CanvasN2.create_text(85,  checkAllignment[varify-1]+unused-5, text=txtF +"Mb")
                                       block[varify] = 0
                       else:
                           exfrag += processFit[t]

                   for c in range(len(My_Blocks)):
                       cText = str(block[c])
                       if BlockUsed[c] == False:
                           if c == 0:
                               w.CanvasN2.create_rectangle(10, 5, 160, checkAllignment[c])
                               w.CanvasN2.create_text(85, checkAllignment[0] - 5, text=cText + "Mb")

                           else:
                               w.CanvasN2.create_rectangle(10, checkAllignment[c - 1], 160, checkAllignment[c])
                               w.CanvasN2.create_text(85, checkAllignment[c] - 20, text=cText + "Mb")



                   for l in range(len(processFit)):

                       if ProcessUsed[l] == False:
                           fit = -1

                           for d in range(len(FreeSpace)):
                              if processFit[l] == FreeSpace[d]:
                                  if fit == -1:
                                      fit = d


                           if fit != -1:
                               txtU = str(processFit[l])
                               unused = FreeSpace[fit] - processFit[l]


                               if fit == 0:
                                   w.CanvasN2.create_rectangle(10, unused + 5, 160, FreeSpace[fit]+5,
                                                              fill="#046363")
                                   w.CanvasN2.create_text(85,  FreeSpace[fit]-10, text= txtU + "Mb", fill = "#0000ff")
                                   infrag -= processFit[l]
                                   exfrag -= processFit[l]

                               else:
                                   print(FreeSpace[fit])
                                   print(checkAllignment)
                                   w.CanvasN2.create_rectangle(10, checkAllignment[fit-1], 160,
                                                                  (FreeSpace[fit]+checkAllignment[fit-1])
                                                              , fill="#046363")
                                   w.CanvasN2.create_text(85,checkAllignment[fit-1]+FreeSpace[fit] - 10,
                                                         text=txtU + "Mb", fill="#0000ff")
                                   infrag -= processFit[l]
                                   exfrag -= processFit[l]

                               FreeSpace.insert(fit, unused)
                       infragtx = str(infrag)
                       exfragtx = str(exfrag)
                       w.LabelN8.configure(text=exfragtx)
                       w.LabelN9.configure(text=infragtx)
                       oneClick = 1


def clearDiagram():
   global processFit, block, exfrag, infrag, oneClick, checkAllignment

   infrag = 0
   exfrag = 0
   oneClick = 0
   w.CanvasN2.delete(ALL)

   w.LabelN8.configure(text=str(infrag))
   w.LabelN9.configure(text=str(exfrag))




############################################





################# Haikal's #################

entries1H = []
entries2H = []
entries3H = []
addEntriesIntH = []
entries1StringH = []
entries2StringH = []
entries3StringH = []
entries2IntH = []
entries3IntH = []
e2H = 0
e3H = 0
etH = 0

def defaultRowH():
   w.rowCountH += 1

   stringRowCountH = "" + str(w.rowCountH)
   en1H = Entry(w.Frame4H, width=39)
   en1H.insert(0, "P" + stringRowCountH)
   en1H.grid(row=w.rowCountH + 1, column=0)
   entries1H.append(en1H)
   en1H.configure(state='disabled')

   en2H = Entry(w.Frame4H, width=39)
   en2H.grid(row=w.rowCountH + 1, column=1)
   entries2H.append(en2H)

   en3H = Entry(w.Frame4H, width=39)
   en3H.grid(row=w.rowCountH + 1, column=2)
   entries3H.append(en3H)


def deleteRowH():
   entries1H[len(entries1H)-1].destroy()
   del entries1H[len(entries1H)-1]
   entries2H[len(entries2H)-1].destroy()
   del entries2H[len(entries2H)-1]
   entries3H[len(entries3H)-1].destroy()
   del entries3H[len(entries3H)-1]
   w.rowCountH -= 1


def createRowH():
    w.rowCountH += 1
    en1H = Entry(w.Frame4H, width=39)
    en1H.grid(row= w.rowCountH+1, column=0)
    entries1H.append(en1H)

    en2H = Entry(w.Frame4H, width=39)
    en2H.grid(row= w.rowCountH+1, column=1)
    entries2H.append(en2H)

    en3H = Entry(w.Frame4H, width=39)
    en3H.grid(row= w.rowCountH+1, column=2)
    entries3H.append(en3H)

    w.Canvas1H.configure(scrollregion=w.Canvas1H.bbox("all"))



def printConsole1H():

    for entry in entries1H:
        entries1StringH.append(str(entry.get()))

    for entry in entries2H:
        entries2StringH.append(str(entry.get()))
        entries2IntH.append(int(entry.get()))

    for entry in entries3H:
        entries3StringH.append(str(entry.get()))
        entries3IntH.append(int(entry.get()))

    for entry1H, entry2H in zip(entries2IntH, entries3IntH):
        addEntriesIntH.append(entry1H + entry2H)

    waitingTimeH = [0] * 10
    turnTimeH = [0] * 10

    k=1
    burstTime2 = 0
    sum = 0
    totalWaitingTime = 0
    ta = 0
    totalTurnTime = 0
    tl = []

    # Sort it according to arrival time
    for i in range(len(entries1StringH)):
            for j in range(len(entries1StringH)):
                if entries2IntH[i] < entries2IntH[j]:
                     temp = entries1StringH[j]
                     entries1StringH[j] = entries1StringH[i]
                     entries1StringH[i] = temp
                     temp = entries2IntH[j]
                     entries2IntH[j] = entries2IntH[i]
                     entries2IntH[i] = temp
                     temp = entries3IntH[j]
                     entries3IntH[j] = entries3IntH[i]
                     entries3IntH[i] = temp


    # Sort table according to Arrival Time,Burst Time Time & Execution Time
    for j in range(len(entries1StringH)):
        burstTime2 = burstTime2 + entries3IntH[j]
        mint = entries3IntH[k]
        for i in range(k, len(entries1StringH)):
            if burstTime2 >= entries2IntH[i] and entries3IntH[i] < mint:
                temp = entries1StringH[k]
                entries1StringH[k] = entries1StringH[i]
                entries1StringH[i] = temp
                temp = entries2IntH[k]
                entries2IntH[k] = entries2IntH[i]
                entries2IntH[i] = temp
                temp = entries3IntH[k]
                entries3IntH[k] = entries3IntH[i]
                entries3IntH[i] = temp
                k += 1

    # Calculate Waiting Time & Average Waiting Time
    waitingTimeH[0] = 0
    for i in range(1, len(entries1StringH)):
        sum = sum + entries3IntH[i - 1]
        waitingTimeH[i] = sum - entries2IntH[i]
        totalWaitingTime = totalWaitingTime + waitingTimeH[i]

    avgWaitingTime = totalWaitingTime / len(entries1String)

    # Calculate Time Line, Total Turn Around Time & Average Waiting Time
    for i in range(len(entries1StringH)):
        ta = ta + entries3IntH[i]
        turnTimeH[i] = ta - entries2IntH[i]
        totalTurnTime = totalTurnTime + turnTimeH[i]
        tl.append(ta)


    avgTurnTime = totalTurnTime / len(entries1String)

    ##################

    w.aveTurnTimeH.configure(text=avgTurnTime)
    w.aveWaitTimeH.configure(text=avgWaitingTime)

    entries3IntH.insert(0,0)
    entries1StringH.insert(0, "")
    tl.insert(0, 0)

    # w.fH = Figure(figsize=(5, 4), dpi=100)
    w.ax = w.fH.add_subplot(2, 1, 1)

    process = ("P1", "P2", "P3", "P4", "P5")

    ind = numpy.arange(1)  # the x locations for the groups
    width = .95

    data = [5,3,1,2,3]
    data1 = [5,8,9,11,14]
    # data1 = [1, 3, 4, 5, 6, 1, 2]

    patch_handles = []
    patch_handles1 = []

    left = 1

    qr = 0
    qriter = 0

    for i, d in enumerate(entries3IntH):
        if (d == 0):
            qr = qriter
        patch_handles.append(w.ax.barh(ind, d, align='center', left=left, yerr=0.4, color='r'))
        left += d

        z= 0

    for j in range(len(patch_handles)):
        for i, patch in enumerate(patch_handles[j].get_children()):
            bl = patch.get_xy()
            x = 0.5 * patch.get_width() + bl[0]
            y = 0.5 * patch.get_height() + bl[1]
            #print(patch.get_width())
            if (patch.get_width() == 0):
                w.ax.text(x, y, entries1StringH[z], ha='center')
            else:
                w.ax.text(x, y, entries1StringH[z], ha='center')
            z+=1

    w.ax.set_yticks(ind)
    w.ax.set_yticklabels(" ")
    w.ax.set_xticks(numpy.cumsum(entries3IntH) + 1)
    w.ax.set_xticklabels(tl)
    # self.ax.set_xlim(1, 20)
    w.ax.set_xlabel('Gantt Chart')
    # self.ax.scatter(1,2,100)

    # w.canvasH = FigureCanvasTkAgg(w.f, master=w.Frame5H)
    w.canvasH.show()
    w.canvasH.get_tk_widget().pack(side=BOTTOM, fill=BOTH, expand=1)

    # toolbarH = NavigationToolbar2TkAgg(w.canvas, root)
    w.toolbarH.update()
    # canvas._canvas.pack(side=TOP, fill=BOTH, expand=True)

    ###############

    # Clear the list used for avoiding index limit errors
    w.i = 0
    w.j = 0
    entries1StringH.clear()
    entries2StringH.clear()
    entries3StringH.clear()
    entries2IntH.clear()
    entries3IntH.clear()
    tl.clear()
    entries1H.clear()
    entries2H.clear()
    entries3H.clear()




#####################################


if __name__ == '__main__':
   import Test
   Test.vp_start_gui()


